<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>图 on 纳兰小筑</title>
    <link>https://www.naah69.com/tags/%E5%9B%BE/</link>
    <description>Recent content in 图 on 纳兰小筑</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Thu, 17 Aug 2017 11:51:17 +0800</lastBuildDate>
    
	<atom:link href="https://www.naah69.com/tags/%E5%9B%BE/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>数据结构图Graph之最终类</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%BB%88%E7%B1%BB/</link>
      <pubDate>Thu, 17 Aug 2017 11:51:17 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%BB%88%E7%B1%BB/</guid>
      <description>该类包括 基础方法 邻接矩阵 邻接表 深度优先遍历 广度优先遍历 最小生成树 最短路径 拓扑排序 package com.naah.s4_Graph; import java.lang.reflect.Array; import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.Stack; /** * * ClassNameCh 图 * ClassNameEn Graph * Description 数据结构图 * Company *</description>
    </item>
    
    <item>
      <title>数据结构图Graph之拓扑排序</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 17 Aug 2017 11:42:36 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>一级压一级 将0入度的输出，之后入度为入度为0的，入度减1，直到入度为0才能输出 通过邻接表与栈实现 算法准备 a. 邻接表 b. 最小权值数组least c. 上</description>
    </item>
    
    <item>
      <title>数据结构图Graph之最短路径问题迪杰斯特拉算法</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 17 Aug 2017 11:36:06 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</guid>
      <description>原理与普里母算法思路相同，只是比较的时候不同 通过邻接矩阵进行计算 算法准备 a. 邻接矩阵 b. 最小权值数组least c. 上一个顶点下标数组lastInd</description>
    </item>
    
    <item>
      <title>数据结构图Graph之最小生成树问题克鲁斯卡尔算法</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 17 Aug 2017 11:31:07 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/</guid>
      <description>算法准备 a. Edge度对象数组（从小到大） b. 查询数组parent c. find方法（查找数组中该顶点能到达的最后位置） 算法思路 a. 遍历edge数组 b.</description>
    </item>
    
    <item>
      <title>数据结构图Graph之最小生成树问题普里姆算法</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 17 Aug 2017 11:25:46 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95/</guid>
      <description>一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。我们把构造连通网的最小代价生成树。称为最小生</description>
    </item>
    
    <item>
      <title>数据结构图Graph之广度优先遍历</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 17 Aug 2017 11:20:16 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</guid>
      <description>广度优先遍历，也称为广度优先搜索。简称BFS 类似于二叉树的层序遍历 算法准备 a. 记录是否遍历过的数组 b. 邻接点的队列 算法思路（递归） a. 从某顶点开始</description>
    </item>
    
    <item>
      <title>数据结构图Graph之深度优先遍历</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 17 Aug 2017 11:10:40 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</guid>
      <description>深度优先遍历，也称为深度优先搜索。简称DFS 它从图中的某个顶点V出发，访问该顶点，然后从v的未被访问的邻接点（出度的点）出发，深度优先遍历图</description>
    </item>
    
  </channel>
</rss>