<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>FOUNDATION on </title>
    <link>https://www.naah69.com/categories/foundation/</link>
    <description>Recent content in FOUNDATION on </description>
    <generator>Hugo -- gohugo.io</generator>
    <language>zh-cn</language>
    <lastBuildDate>Sat, 09 Sep 2017 11:46:51 +0800</lastBuildDate>
    
	<atom:link href="https://www.naah69.com/categories/foundation/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>算法基础之回溯算法</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 09 Sep 2017 11:46:51 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%9B%9E%E6%BA%AF%E7%AE%97%E6%B3%95/</guid>
      <description>回溯算法 回溯法（探索与回溯法）是一种选优搜索法，又称为试探法，按选优条件向前搜索，以达到目标。但当探索到某一步时，发现原先选择并不优或达不到</description>
    </item>
    
    <item>
      <title>算法基础之动态规划</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</link>
      <pubDate>Sat, 09 Sep 2017 11:43:36 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</guid>
      <description>动态规划 把多阶段过程转化为一系列单阶段问题，利用各阶段之间的关系，逐个求解，创立了解决这类过程优化问题的新方法——动态规划 算法应用 最长公共子</description>
    </item>
    
    <item>
      <title>算法基础之分治算法</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 09 Sep 2017 11:39:38 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E5%88%86%E6%B2%BB%E7%AE%97%E6%B3%95/</guid>
      <description>分治算法 分治算法的基本思想是将一个规模为N的问题分解为K个规模较小的子问题，这些子问题相互独立且与原问题性质相同。求出子问题的解，就可得到原</description>
    </item>
    
    <item>
      <title>算法基础之贪心算法</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 09 Sep 2017 11:33:44 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95/</guid>
      <description>贪心算法 贪心算法（又称贪婪算法）是指，在对问题求解时，总是做出在当前看来是最好的选择。也就是说，不从整体最优上加以考虑，他所做出的是在某种意</description>
    </item>
    
    <item>
      <title>算法基础之穷举算法</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A9%B7%E4%B8%BE%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 09 Sep 2017 11:28:38 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E7%A9%B7%E4%B8%BE%E7%AE%97%E6%B3%95/</guid>
      <description>穷举算法 穷举法的基本思想是根据题目的部分条件确定答案的大致范围，并在此范围内对所有可能的情况逐一验证，直到全部情况验证完毕。若某个情况验证符</description>
    </item>
    
    <item>
      <title>算法基础之递归算法</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</link>
      <pubDate>Sat, 09 Sep 2017 11:24:55 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95/</guid>
      <description>递归算法 递归算法是把问题转化为规模缩小了的同类问题的子问题。然后 递归调用函数（或过程）来表示问题的解。 一个过程(或函数)直接或间接调用自己本</description>
    </item>
    
    <item>
      <title>算法基础之排序算法九之基数排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%9D%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 09:31:05 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B9%9D%E4%B9%8B%E5%9F%BA%E6%95%B0%E6%8E%92%E5%BA%8F/</guid>
      <description>基数排序 基数排序（radix sort）属于“分配式排序”（distribution sort），又称“桶子法”（bucket sort）或bin</description>
    </item>
    
    <item>
      <title>算法基础之排序算法八之归并排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%AB%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 09:25:26 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%AB%E4%B9%8B%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/</guid>
      <description>归并排序 归并排序（MERGE-SORT）是建立在归并操作上的一种有效的排序算法,该算法是采用分治法（Divide and Conquer）的一个非常</description>
    </item>
    
    <item>
      <title>算法基础之排序算法七之快速排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%83%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 09:22:37 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%83%E4%B9%8B%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/</guid>
      <description>选择排序算法 选择排序（Selection sort）是一种简单直观的排序算法。 它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个</description>
    </item>
    
    <item>
      <title>算法基础之排序算法六之冒泡排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%AD%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 09:20:31 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%85%AD%E4%B9%8B%E5%86%92%E6%B3%A1%E6%8E%92%E5%BA%8F/</guid>
      <description>交换排序算法 所谓交换，就是根据序列中两个记录键值的比较结果来对换这两个记录在序列中的位置，稳定的算法 交换排序的特点是：将键值较大的记录向序列</description>
    </item>
    
    <item>
      <title>算法基础之排序算法五之堆排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BA%94%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 09:16:48 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BA%94%E4%B9%8B%E5%A0%86%E6%8E%92%E5%BA%8F/</guid>
      <description>选择排序算法 选择排序（Selection sort）是一种简单直观的排序算法。 它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个</description>
    </item>
    
    <item>
      <title>算法基础之排序算法四之简单选择排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%9B%E4%B9%8B%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 09:09:45 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%9B%9B%E4%B9%8B%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F/</guid>
      <description>选择排序算法 选择排序（Selection sort）是一种简单直观的排序算法。 它的工作原理是每一次从待排序的数据元素中选出最小（或最大）的一个</description>
    </item>
    
    <item>
      <title>算法基础之排序算法三之希尔排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%89%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 08:59:49 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%89%E4%B9%8B%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F/</guid>
      <description>插入排序算法 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序</description>
    </item>
    
    <item>
      <title>算法基础之排序算法二之折半插入排序（二分插入排序）</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BA%8C%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 08:56:18 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%BA%8C%E4%B9%8B%E6%8A%98%E5%8D%8A%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F-%E4%BA%8C%E5%88%86%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>插入排序算法 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序</description>
    </item>
    
    <item>
      <title>算法基础之排序算法一之直接插入排序</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%80%E4%B9%8B%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Sat, 09 Sep 2017 08:54:28 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E4%B8%80%E4%B9%8B%E7%9B%B4%E6%8E%A5%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F/</guid>
      <description>插入排序算法 有一个已经有序的数据序列，要求在这个已经排好的数据序列中插入一个数，但要求插入后此数据序列仍然有序，这个时候就要用到一种新的排序</description>
    </item>
    
    <item>
      <title>算法基础之思维导图</title>
      <link>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</link>
      <pubDate>Sat, 09 Sep 2017 08:43:46 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-09-09-%E7%AE%97%E6%B3%95%E5%9F%BA%E7%A1%80%E4%B9%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</guid>
      <description></description>
    </item>
    
    <item>
      <title>数据结构之思维导图</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</link>
      <pubDate>Thu, 17 Aug 2017 11:58:48 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B9%8B%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE/</guid>
      <description>通过这些天对数据结构的学习，使用思维导图进行了总结</description>
    </item>
    
    <item>
      <title>数据结构图Graph之最终类</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%BB%88%E7%B1%BB/</link>
      <pubDate>Thu, 17 Aug 2017 11:51:17 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%BB%88%E7%B1%BB/</guid>
      <description>该类包括 基础方法 邻接矩阵 邻接表 深度优先遍历 广度优先遍历 最小生成树 最短路径 拓扑排序 package com.naah.s4_Graph; import java.lang.reflect.Array; import java.util.Arrays; import java.util.LinkedList; import java.util.List; import java.util.Stack; /** * * ClassNameCh 图 * ClassNameEn Graph * Description 数据结构图 * Company *</description>
    </item>
    
    <item>
      <title>数据结构图Graph之拓扑排序</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</link>
      <pubDate>Thu, 17 Aug 2017 11:42:36 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%8B%93%E6%89%91%E6%8E%92%E5%BA%8F/</guid>
      <description>一级压一级 将0入度的输出，之后入度为入度为0的，入度减1，直到入度为0才能输出 通过邻接表与栈实现 算法准备 a. 邻接表 b. 最小权值数组least c. 上</description>
    </item>
    
    <item>
      <title>数据结构图Graph之最短路径问题迪杰斯特拉算法</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 17 Aug 2017 11:36:06 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E8%BF%AA%E6%9D%B0%E6%96%AF%E7%89%B9%E6%8B%89%E7%AE%97%E6%B3%95/</guid>
      <description>原理与普里母算法思路相同，只是比较的时候不同 通过邻接矩阵进行计算 算法准备 a. 邻接矩阵 b. 最小权值数组least c. 上一个顶点下标数组lastInd</description>
    </item>
    
    <item>
      <title>数据结构图Graph之最小生成树问题克鲁斯卡尔算法</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 17 Aug 2017 11:31:07 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E5%85%8B%E9%B2%81%E6%96%AF%E5%8D%A1%E5%B0%94%E7%AE%97%E6%B3%95/</guid>
      <description>算法准备 a. Edge度对象数组（从小到大） b. 查询数组parent c. find方法（查找数组中该顶点能到达的最后位置） 算法思路 a. 遍历edge数组 b.</description>
    </item>
    
    <item>
      <title>数据结构图Graph之最小生成树问题普里姆算法</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95/</link>
      <pubDate>Thu, 17 Aug 2017 11:25:46 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%9C%80%E5%B0%8F%E7%94%9F%E6%88%90%E6%A0%91%E9%97%AE%E9%A2%98%E6%99%AE%E9%87%8C%E5%A7%86%E7%AE%97%E6%B3%95/</guid>
      <description>一个连通图的生成树是一个极小的连通子图，它含有图中全部的顶点，但只有足以构成一棵树的n-1条边。我们把构造连通网的最小代价生成树。称为最小生</description>
    </item>
    
    <item>
      <title>数据结构图Graph之广度优先遍历</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 17 Aug 2017 11:20:16 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</guid>
      <description>广度优先遍历，也称为广度优先搜索。简称BFS 类似于二叉树的层序遍历 算法准备 a. 记录是否遍历过的数组 b. 邻接点的队列 算法思路（递归） a. 从某顶点开始</description>
    </item>
    
    <item>
      <title>数据结构图Graph之深度优先遍历</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 17 Aug 2017 11:10:40 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%9B%BEgraph%E4%B9%8B%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86/</guid>
      <description>深度优先遍历，也称为深度优先搜索。简称DFS 它从图中的某个顶点V出发，访问该顶点，然后从v的未被访问的邻接点（出度的点）出发，深度优先遍历图</description>
    </item>
    
    <item>
      <title>数据结构查找二叉树SearchBinaryTree之JAVA代码</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91searchbinarytree%E4%B9%8Bjava%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 17 Aug 2017 11:00:26 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9F%A5%E6%89%BE%E4%BA%8C%E5%8F%89%E6%A0%91searchbinarytree%E4%B9%8Bjava%E4%BB%A3%E7%A0%81/</guid>
      <description>下面是我自己写的查找二叉树的结构： 希望对各位有所帮助，如果有错误的地方或更好的建议，请不吝赐教，谢谢 构建查找二叉树 查找二叉树添加节点方法 在某</description>
    </item>
    
    <item>
      <title>数据结构二叉树BinaryTree之java构建二叉树JAVA代码</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91binarytree%E4%B9%8Bjava%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java%E4%BB%A3%E7%A0%81/</link>
      <pubDate>Thu, 17 Aug 2017 10:52:45 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91binarytree%E4%B9%8Bjava%E6%9E%84%E5%BB%BA%E4%BA%8C%E5%8F%89%E6%A0%91java%E4%BB%A3%E7%A0%81/</guid>
      <description>经过几天的学习，简单的编写了一个二叉树的类 其中包括 属性 根节点 方法 层序构建二叉树 前序构建二叉树 得到当前的深度 得到当前的节点数 前序遍历 中序遍历 后</description>
    </item>
    
    <item>
      <title>数据结构二叉树BinaryTree之遍历</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91binarytree%E4%B9%8B%E9%81%8D%E5%8E%86/</link>
      <pubDate>Thu, 17 Aug 2017 10:46:27 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91binarytree%E4%B9%8B%E9%81%8D%E5%8E%86/</guid>
      <description>1.前序遍历 规则为若二叉树为空，则返回空，否则按如下顺序进行访问 访问根节点 访问左节点 访问右节点 总结：中左右 顺序：中左右 规律：要访问的放中间 每</description>
    </item>
    
    <item>
      <title>数据结构二叉树BinaryTree之性质&#43;推导</title>
      <link>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91binarytree%E4%B9%8B%E6%80%A7%E8%B4%A8-%E6%8E%A8%E5%AF%BC/</link>
      <pubDate>Thu, 17 Aug 2017 10:42:52 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-17-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%BA%8C%E5%8F%89%E6%A0%91binarytree%E4%B9%8B%E6%80%A7%E8%B4%A8-%E6%8E%A8%E5%AF%BC/</guid>
      <description>由于无法打出上下标效果，所以本节采用截图形式 性质1：在二叉树的第i层上至多有2^(i-1)个结点（i&amp;gt;=1） 性质2：深度为k的二叉树至</description>
    </item>
    
    <item>
      <title>数据结构键值HashMap之自己编写简单的HashMap</title>
      <link>https://www.naah69.com/post/2017-08-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%94%AE%E5%80%BChashmap%E4%B9%8B%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84hashmap/</link>
      <pubDate>Thu, 10 Aug 2017 03:26:17 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-10-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E9%94%AE%E5%80%BChashmap%E4%B9%8B%E8%87%AA%E5%B7%B1%E7%BC%96%E5%86%99%E7%AE%80%E5%8D%95%E7%9A%84hashmap/</guid>
      <description>通过key计算二次哈希值，然后哈希值与数组长度进行与运算 总结： 得到的结果便是数组的下标 通过该种索引方法可以实现查询优化 通过key计算二次哈希</description>
    </item>
    
    <item>
      <title>数据结构Stack之中缀表达式转后缀表达式运算应用</title>
      <link>https://www.naah69.com/post/2017-08-08-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84stack%E4%B9%8B%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97%E5%BA%94%E7%94%A8/</link>
      <pubDate>Tue, 08 Aug 2017 12:59:05 +0800</pubDate>
      
      <guid>https://www.naah69.com/post/2017-08-08-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84stack%E4%B9%8B%E4%B8%AD%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BD%AC%E5%90%8E%E7%BC%80%E8%A1%A8%E8%BE%BE%E5%BC%8F%E8%BF%90%E7%AE%97%E5%BA%94%E7%94%A8/</guid>
      <description>通过学习java中的Stack栈，写一个一个简单的中缀表达式转换为后缀表达式并计算的应用 由于时间问题，没有写字符分割函数。暂时用空格进行分割</description>
    </item>
    
  </channel>
</rss>